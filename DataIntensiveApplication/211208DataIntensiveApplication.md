# 데이터 중심 애플리케이션 책을 보게 된 이유

* 회사에서 부서장님이 추천함
* 데이터 엔지니어로서 다양한 빅데이터 시스템을 이해하기 위해서 추상적인 설계 방식에 대한 쓰여진 책이라 도움이 될것으로 판단해 처음부터 끝까지 정리하고자 함

# 차례

* Part1. 데이터 시스템의 기초
  * 신뢰성, 확장성, 유지보수성
  * 데이터 모델과 질의언어
  * 저장소와 검색
* Part2. 분산 데이터
  * 부호화
  * 복제
  * 파티셔닝
  * 트랜잭션
  * 분산 시스템에서 발생할 수 있는 문제
  * 일관성과 합의
* Part3. 파생 데이터
  * 일괄 처리
  * 스트림 처리
  * 데이터 시스템의 미래

# Part1. 데이터 시스템의 기초

* 애플리케이션 요구사항의 변화
  * 예전에는 compute-intensive하였으나 이젠 data-intensive
  * cpu성능 -> 데이터 양, 복잡도, 변화속도
* 신뢰성, 확장성, 유지보수성
* 신뢰성
  * 결함에 직면해도 시스템이 원하는 성능 수준에서 정확한 기능 수행
  * 시스템이 안정적으로 작동하지 않으면 매출, 명성에 타격을 주어 많은 비용이 들게 된다
  * 결함 유형
    * 하드웨어 결함
      * 하드디스크 고장, 램 결함, 대규모 정전, 네트워크 케이블을 잘못 뽑은 것
      * 하드웨어 장비 중목, 소프트웨어 내결함성 기술을 사용하여 해결
    * 소프트웨어 오류
      * 시스템 내 체계적 오류
      * 잘못된 특정 입력이 있을 때 모든 애플리케이션 서버 인스턴스 정지, 공유자원(cpu시간, 메모리, 디스크공간, 네트워크 대역폭)을 과도하게 사용하는 프로세스, 시스템의 속도가 느려져 반응이 없거나 잘못된 응답 반환하는 서비스, cascading failure
      * 빈틈없는 테스트, 프로세스 격리, 죽은 프로세스 재시작 허용, 프로덕션 환경에서 시스템 동작의 측정, 모니터링
    * 인적 오류
      * 운영자의 설정 오류
      * 오류의 가능성을 최소화하는 추상화, 사람이 많이 실수하는 부분 분리, 실제 데이터를 미리 실험해볼 수 있는 샌드박스, 단위 테스트부터 시스템 통합 테스트를 철저히하기, 장애 발생의 영향을 최소화하기 위해 새로운 코드는 서서히 roll out/잘못된 코드는 빠른 roll back, 성능 지표와 오류율같은 명확한 모니터링
* 확장성
  * 증가한 부하에 대해 대처할 수 있는 시스템 능력
  * 시스템 현재 부하를 간결(웹 서버의 초당 요청수, 데이터베이스의 읽기 대 쓰기 비율, 대화방의 동시 활성 사용자, 캐시적중률)하게 기술하여야 부하 예측에 대한 논의가 가능하다
  * 트위터의 확장성
    * 사용자가 자신의 홈 타임라인을 요청하면 팔로우한 모든 사람의 트윗을 시간순대로 정렬하여 보여줘야 한다
    * 첫번째 방식 : 사용자는 자신의 홈 타임라인을 **요청**하는 순간 관계형 데이터베이스에 위의 질의를 하는 **쿼리**를 날린다
    * 두번째 방식 : 사용자가 트윗을 **작성**하면 해당 사용자를 팔로우하는 사람들을 모두 찾고 각자의 홈 타임라인 **캐시**에 새로운 트윗을 삽입한다. 사용자는 자신의 홈 타임라인을 요청하면 타임라인 캐시에 있는 요청결과를 가져온다
    * 팔로워가 적을 경우 두번째 방식이 더 빠르고, 팔로워가 많을 경우 첫번째 방식이 더 빠르다
  * 성능 수치 기술
    * 하둡과 온라인 시스템
      * 하둡은 처리량이 중요하고 온라인 시스템에서는 응답 시간이 중요하다
    * 응답시간
      * 일반적인 사용자가 느끼는 지연정도를 알고 싶으면 중앙값
      * 아마존의 경우 가장 소중한 고객이 응답 시간이 가장 느린 요청을 경험한 고객이라 99.9분위인 tail latency에 대해 신경쓴다(서비스 수준 목표 SLO, 서비스 수준 협약서 SLA)
      * 서버 응답 시간이 아닌 클라이언트 응답 시간 측정이 중요
    * 읽기 양, 쓰기 양, 저장할 데이터 양, 데이터 복잡도, 접근 패턴 등이 있다
  * 부하 대응 방법 2가지 : scaling up(수직확장), scaling out(수평확장)
  * 탄력적(elastic)
    * 부하 증가를 감지하면 컴퓨팅 자원을 자동으로 추가하는 시스템
    * 부하를 예측할 수 없을 만큼 높은 경우 유용하지만, 수동으로 확장하는 시스템이 더 간단하고 운영상 예상치 못한 일이 더 적다
* 유지보수성
  * 운용성, 단순성, 발전성을 달성하는 시스템 능력
  * 시스템에서 작업하는 엔지니어, 운영 팀의 삶을 개선하는 것이 목표
  * 운용성
    * 동일하게 반복되는 태스크를 쉽게 수행하게끔 만들어 운영팀이 고부가가치 활동에 노력을 집중하게 할 수 있는 능력
    * 시스템 상태를 모니터링
    * 표준 도구를 이용해 자동화와 통합을 위한 우수한 지원
    * 유지보수를 위해 장비를 내려도 시스템 전체에 영향을 주지않고 운영 가능
    * 좋은 문서, 이해하기 쉬운 운영 모델
    * 만족할만한 기본 동작을 제공하고, 필요할 때 기본값을 다시 정의할 수 있는 자유를 관리자에게 부여
    * 자기회복이 가능하고, 필요하면 관리자가 시스템 상태를 수동으로 제어가능
    * 예측 가능하게 동작
  * 단순성
    * 개발자가 시스템을 이해하고 추론하기 어려워지지 않도록 시스템을 단순하게 만드는 것
    * 복잡도가 높은 상황
      * 상태(stateful) 공간의 급증
      * 모듈 간 강한 커플링(높은 결합도)
      * 복잡한 의존성
      * 일관성 없는 이름짓기
      * 성능 문제 해결을 목표로 한 해킹
      * 임시방편으로 문제를 해결한 특수 사례
    * 복잡도를 줄이기 위해 추상화를 사용한다
    * 좋은 추상화는 필요한 부분만 볼 수 있게 해주고 재사용을 가능하게 한다
  * 발전성
    * 시스템 요구사항이 바뀔 때 시스템 변경을 쉽고 빠르게 할 수 있는 것
    * 요구사항이 자주 변하는 환경에서 도움이 되는 기술인 애자일, TDD, 리팩토링 등  도입필요
* 데이터 모델
  * 관계형 모델
    * 데이터가 관계(relation)로 구성되고, 각 관계가 순서없는 튜플(tuple) 모음으로 되어있는 것
    * SQL
    * 다양한 비즈니스 데이터 처리에 사용(온라인 게시물, 토론, 소셜 네트워크, 전자 상거래, 게임, SaaS 생산성 애플리케이션)
    * 객체지향 프로그래밍 언어의 데이터를 관계형 테이블에 저장하는 일이 많은데, 이 때 필요한 코드 양을 줄이기 위해 객체 관계형 매핑(ORM) 프레임워크를 사용한다
    * one-to-many 관계의 경우 불필요하게 스키마를 나누어 비효율적일 수도 있다(ex 한사람에 대한 모든 정보를 하나의 이력서를 저장하면 되는 경우를 positions, education, contact_info등 여러 테이블로 나누는 경우)
    * one-to-many, many-to-one, many-to-many 관계를 모두 외래키를 사용하는 join으로 해결할 수 있다
    * 외래키 여부와 상관없이 자유롭게 데이터(row) 추가 가능
    * 데이터 질의시 query optimizer가 자동으로 최적의 접근 경로를 찾을 수 있고, 해당 데이터베이스를 사용하는 모든 어플리케이션이 혜택을 받을 수 있다
    * schema-on-write : 쓰여진 모든 데이터가 스키마를 따른다는 것을 보장, 정적 타입 확인
  * 문서 모델
    * 대규모 데이터셋, 매우 높은 쓰기 처리량 달성을 위해 관계형 데이터베이스보다 뛰어난 확장성을 가진 데이터베이스 필요
    * 무료 오픈소스에 대한 선호도
    * 관계형 모델에서 지원하지 않는 특수 질의 동작
    * 관계형 스키마 제한에 대한 불만, 동적이고 표현력이 풍부한 데이터 모델에 대한 바람
    * NoSQL
    * 객체지향 프로그래밍 언어의 데이터는 문서형태(JSON, XML)로 변환하기 쉽다
    * JSON과 같은 문서는 다중 테이블 스키마보다 더 나은 지역성을 가진다
    * 지역성은 한 번에 해당 문서의 많은부분을 필요로하는 경우에만 적용되기 때문에, 문서의 크기가 지나치게 큰 경우 전체 문서를 적재하여 낭비일 수 있다
    * 지역성을 위해 관련 데이터를 그룹화하는 문서 모델이 아닌 데이터베이스는 구글 Spanner 데이터베이스, 오라클의 다중 테이블 색인 클러스터 테이블, Bigtable, column-family 적용 DB(카산드라, HBase) 등이 있다
    * one-to-many 관계에 대해서는 조인이 필요없이 쉽게 보여줄 수 있다
    * many-to-one, many-to-many 관계에 대해서는 join 지원이 약하여 적합하지 않다(document reference로 join이 가능하긴 하다)
    * schema-on-read : 데이터 구조는 꼭 지키지 않아도 되는 스키마가 존재하고 데이터를 읽을 때만 스키마에 따른다, 동적 타입 확인
  * 네트워크 모델
    * CODASYL(코다실)
    * 네트워크 모델에서 레코드는 다중 부모가 있을 수 있다
    * one-to-many, many-to-one, many-to-many 관계 모두 최상위 레코드에서부터 연속된 연결 경로를 따라가면서 모델링가능
    * 테이프 드라이브(탐색이 매우 느린)와 같이 매우 제한된 하드웨어 성능을 가장 효율적으로 사용가능
    * 데이터베이스 질의, 갱신 코드가 복잡
    * 접근 경로를 변경하면 수많은 데이터베이스 질의 코드를 살펴보고 재작성해야하는 어려움
  * 문서 데이터베이스와 관계형 데이터베이스의 통합
    * 대부분 관계형 데이터베이스 시스템은 2000년대 중반 이후 XML, JSON을 지원한다
    * 문서 데이터베이스도 RethinkDB는 관계형 조인을 지원하고, MongoDB도 드라이버가 자동으로 데이터베이스 참조를 확인한다
    * 각 데이터 모델이 서로 부족한 부분을 보완해가고 있다
* 질의 언어

